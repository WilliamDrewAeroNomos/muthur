package com.csc.muthur.server.commons;import java.util.Dictionary;import org.osgi.service.cm.ConfigurationException;import org.osgi.service.cm.ManagedService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class MessagingConfigurator implements ManagedService {	private static final Logger LOG = LoggerFactory			.getLogger(MessagingConfigurator.class.getName());	private Integer dataChannelServerPort = 54545;	private String dataChannelServerHostName = "localhost";	private Integer messagingPort = 61616;	private String messagingTransport = "tcp";	private String messagingHost = "localhost";	private Boolean generateHeartBeat = Boolean.TRUE;	private Integer intervalBetweenHeartBeatsSecs = new Integer(5);	private Integer maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed =			new Integer(0);	/**	 * 	 */	public MessagingConfigurator() {	}	/**	 * 	 * @param props	 * @throws ConfigurationException	 */	public MessagingConfigurator(final Dictionary<?, ?> props)			throws ConfigurationException {		if (props != null) {			updated(props);		}	}	/*	 * (non-Javadoc)	 * 	 * @see org.osgi.service.cm.ManagedService#updated(java.util.Dictionary)	 */	@SuppressWarnings("rawtypes")	public void updated(Dictionary props) throws ConfigurationException {		if (props == null) {			LOG.debug("No configuration from configuration admin or "					+ "old configuration has been deleted");		} else {			LOG.debug("Messaging properties updated - [" + props + "] from ["					+ props.get("felix.fileinstall.filename") + "]");			/*			 * messagingPort			 */			String value = (String) props.get("messagingPort");			if (value != null) {				messagingPort = Integer.valueOf(value);			}			messagingTransport = (String) props.get("messagingTransport");			messagingHost = (String) props.get("messagingHost");			/*			 * generateHeartBeat			 */			value = (String) props.get("generateHeartBeat");			if (value != null) {				generateHeartBeat = Boolean.valueOf(value);			}			/*			 * intervalBetweenHeartBeatsSecs			 */			value = (String) props.get("intervalBetweenHeartBeatsSecs");			if (value != null) {				intervalBetweenHeartBeatsSecs = Integer.valueOf(value);			}			/*			 * maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed			 */			value =					(String) props							.get("maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed");			if (value != null) {				maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed =						Integer.valueOf(value);			}			/*			 * dataChannelServerHostName			 */			value = (String) props.get("dataChannelServerHostName");			if (value != null) {				dataChannelServerHostName = value;			}			/*			 * dataChannelServerPort			 */			value = (String) props.get("dataChannelServerPort");			if (value != null) {				dataChannelServerPort = Integer.valueOf(value);			}			LOG.info("Messaging properties set : " + props);		}	}	/**	 * @return the messagingPort	 */	public final Integer getMessagingPort() {		return messagingPort;	}	/**	 * @return the messagingTransport	 */	public final String getMessagingTransport() {		return messagingTransport;	}	/**	 * @return the messagingHost	 */	public final String getMessagingHost() {		return messagingHost;	}	/**	 * 	 * @return URL used by all services to connect to the message transport	 *         service	 * 	 *         example url = failover:(tcp://primary:61616)?timeout=3000	 */	public final String getConnectionUrl() {		String connectionUrl = new String();		if ((getMessagingHost() != null) && (getMessagingTransport() != null)				&& (getMessagingPort() != null)) {			connectionUrl =					"failover:(" + getMessagingTransport() + "://" + getMessagingHost()							+ ":" + Integer.toString(getMessagingPort()) + ")?timeout=60000";		}		return connectionUrl;	}	/**	 * @return the generateHeartBeat	 */	public final Boolean getGenerateHeartBeat() {		return generateHeartBeat;	}	/**	 * @param generateHeartBeat	 *          the generateHeartBeat to set	 */	public final void setGenerateHeartBeat(Boolean generateHeartBeat) {		this.generateHeartBeat = generateHeartBeat;	}	/**	 * @return the intervalBetweenHeartBeatsSecs	 */	public Integer getIntervalBetweenHeartBeatsSecs() {		return intervalBetweenHeartBeatsSecs;	}	/**	 * @param intervalBetweenHeartBeatsSecs	 *          the intervalBetweenHeartBeatsSecs to set	 */	public void setIntervalBetweenHeartBeatsSecs(			Integer intervalBetweenHeartBeatsSecs) {		this.intervalBetweenHeartBeatsSecs = intervalBetweenHeartBeatsSecs;	}	/**	 * @return the maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed	 */	public Integer getMaxNumOfConsecutiveFailedHeartbeatAttemptsAllowed() {		return maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed;	}	/**	 * @param maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed	 *          the maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed to set	 */	public void setMaxNumOfConsecutiveFailedHeartbeatAttemptsAllowed(			Integer maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed) {		this.maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed =				maxNumOfConsecutiveFailedHeartbeatAttemptsAllowed;	}	/**	 * @return the dataChannelServerPort	 */	public Integer getDataChannelServerPort() {		return dataChannelServerPort;	}	/**	 * @param dataChannelServerPort	 *          the dataChannelServerPort to set	 */	public void setDataChannelServerPort(Integer dataChannelServerPort) {		this.dataChannelServerPort = dataChannelServerPort;	}	/**	 * @return the dataChannelServerHostName	 */	public String getDataChannelServerHostName() {		return dataChannelServerHostName;	}	/**	 * @param dataChannelServerHostName	 *          the dataChannelServerHostName to set	 */	public void setDataChannelServerHostName(String dataChannelServerHostName) {		this.dataChannelServerHostName = dataChannelServerHostName;	}}